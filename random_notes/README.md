
# Career wisdom

## [What do the top 1% of software engineers do that the other 99% do not?](https://qr.ae/priipb)

By Piaw Na

- Invest in learning and building tools.
  - I've yet to meet a top engineer who didn't acquire mastery of their editor (EMACS, vi, etc), source control system, debuggers (though that's sadly going away), and programming environment.
  - By contrast, mediocre programmers can (for example) edit code in EMACS but don't treat it like a development environment either to speed up the edit/compile/debug cycle or to reduce memory load (by off-loading knowledge of where a function is by using TAGS or some meta-search tool).
  - Top engineers not only understand all the basic features, but usually make heavy use of the extension languages and customizability of their environment.
- Give credit where credit is due.
  - Again, if you're a top engineer, you don't need to hoard credit and can happily acknowledge other people's work. This makes other great people want to work with you, and it's a self-fulfilling cycle.
- Impatience.
  - Rather than wanting to spend time in meetings, top engineers write code, and spend time writing code rather than talking about it. Jeff Dean, Pengtoh, and Amit Singh have done major code changes to Google infrastructure without hesitancy. As Bill Coughran once said, "You come in one morning and discover that the universe has changed."
- Total stack comprehension.
  - Great software engineers don't stop at an abstraction or module boundaries. They penetrate those boundaries and attack problems or bugs until they solve them.
  - I was once sitting down next to Pengtoh while he dug down into misbehaving code and discovered a bug in the assembly the compiler was generating. He then figured out a stable workaround for that bug.
- If you're intimidated by abstractions or have too much respect for module boundaries, you wouldn't have found that bug.
- If you do all of those 4, there's zero chance you won't be one of the top 1%.

## [What makes a 10x programmer/software engineer?](https://qr.ae/prNbQa)

by Jessica Su from Quora post

- You become a 10x engineer by making ten engineers twice as productive. You unblock other engineers and help them fix their most difficult issues.
- The whole system is broken and no one can do any work. Every hour the system is broken is 10 wasted hours of engineering time. You fix the system in 1 hour. You are a 10x engineer.
- Your friend would have spent three days fixing a bug. Instead, he asks you for help, and you solve it in 1 hour. Your 1 hour saved the other guy 24 business hours. You are a 24x engineer.
- Your friend writes a diff with a bug in it. You review the code and find the bug before he puts it in production. If it had made it to production, it would have cost 5 hours of time to fix, but you found it in 15 minutes. You are a 20x engineer.
- Your team’s code has no unit tests. You add a bunch of unit tests to the code. Other people copy the style of your code, so soon there are hundreds of unit tests. Now bugs that took days to catch are being found immediately. You are a 50x engineer.
- Your friend is doing a project. You learn that someone else on another team is doing exactly the same thing. You take them both out for ice cream, and they find a way to work together. They save 6 months of development time. You are a 200x engineer.
- Your friend is unhappy and thinking about leaving the company. You coach him and talk him through his problems. He becomes happier and decides to stay. Replacing him and ramping up a new team member would have taken 6 months. You are a 200x engineer.

## [What is the skill that made you a productive programmer?](https://qr.ae/preHd0)

by Kurt Guntheroth from Quora post

- Humility:
  - When I stopped arguing with people who said there was a bug in the code, and just tried to make it work the way they wanted it, I saved a lot of time.
- Focus:
  - When I stopped allowing myself to be distracted by email, web surfing, cleaning my desk, or any other task beside writing code, I wrote a lot more code.
- Intensity:
  - When I was staring at an empty screen, and forced myself to write something, instead of worrying endlessly about which of several ways I should go, I stopped being blocked by indecision.
- Abstraction:
  - When I started writing function calls as placeholders for subsystems I didn’t know how to create yet, I made more progress on the big picture. The subsystems were easy to write once the big picture was filled in. This is a great way to do coding interviews too.
- Documentation:
  - When I wrote down in my favorite natural language what I wanted to do in code, it made the coding task clear. When I returned to the code six months later, it was still clear. When I wrote down how to use infrequently used tools, I could use the tool again a year later, without having to learn to use the tool all over again. When I documented processes, I helped every member of my team, from that time forward.
- Automated Tests:
  - When I wrote tests, it paid back the time I invested the second time I ran the tests. And I ran the tests way more than twice.
- Research:
  - When I looked patiently for a solution, there was someone to light the way. Whenever I search on the Web whether a thing is possible, the first search result always seems to say that it is not. Then I find ten results that say it is not possible. Then I find a person who says, “I did it, and this is how.”
- Responsibility:
  - I realized my job is to write software. I make the same excellent wage whether I’m adding unique features, chasing imaginary requirements, or cleaning toilets. If my manager orders me to do something dumb over my stated objections, it’s on him, not me.

## [How aggressive do software engineers have to be to get promotions?](https://qr.ae/prT3gw)

by Mohammed Islam from Quora post

> - What’s the difference between a rockstar developer and a mediocre one? The rockstar’s software works as intended. Period.
> - When a software engineer does a good job, things work. They don’t work better, or more, or prettier. It just works, without any fuss, groans, or jerky behavior.
> - A good software architect can have 100x the impact on the company than the good developer does. But the impact is the kind where bad things didn’t happen. How do you give someone credit for what didn’t happen? So it requires courage, and boldness. And yes, sometimes aggression, to get the recognition that you deserve.

## Good system design is not about getting 10x wins in performance or efficiency or cost. It's about reducing complexity via abstraction; and in the process, enabling people you haven't yet met to solve problems (or leverage opportunities) that you can't currently anticipate.

- [tweet by maheshb](https://twitter.com/maheshb/status/1634423302340100096?s=20)